{"DateTime":{"add":{"s":"Adds an amount of days, months, years, hours, minutes and seconds to a\n   DateTime object","y":"public DateTime DateTime::add\n    ( DateInterval $interval\n   )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"interval","d":"A DateInterval object"}]},"__construct":{"s":"Returns new DateTime object","y":"","p":[{"t":"time","d":"A date\/time string. Valid formats are explained in Date and Time Formats."},{"t":"timezone","d":"A DateTimeZone object representing the\n      timezone of $time."}]},"createFromFormat":{"s":"Returns new DateTime object formatted according to the specified format","y":"public static DateTime DateTime::createFromFormat\n    ( string $format\n   , string $time\n   [, DateTimeZone $timezone\n  ] )","p":[{"t":"format","d":"The format that the passed in string should be in. See the\n      formatting options below. In most cases, the same letters as for the\n      date() can be used."},{"t":"time","d":"String representing the time."},{"t":"timezone","d":"A DateTimeZone object representing the\n      desired time zone."}]},"getLastErrors":{"s":"Returns the warnings and errors","y":"public static array DateTime::getLastErrors\n    ( void\n   )","p":null},"modify":{"s":"Alters the timestamp","y":"public DateTime DateTime::modify\n    ( string $modify\n   )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"modify","d":"A date\/time string. Valid formats are explained in Date and Time Formats."}]},"__set_state":{"s":"The __set_state handler","y":"public static DateTime DateTime::__set_state\n    ( array $array\n   )","p":[{"t":"array","d":"Initialization array."}]},"setDate":{"s":"Sets the date","y":"public DateTime DateTime::setDate\n    ( int $year\n   , int $month\n   , int $day\n   )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"year","d":"Year of the date."},{"t":"month","d":"Month of the date."},{"t":"day","d":"Day of the date."}]},"setISODate":{"s":"Sets the ISO date","y":"public DateTime DateTime::setISODate\n    ( int $year\n   , int $week\n   [, int $day = 1\n  ] )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"year","d":"Year of the date."},{"t":"week","d":"Week of the date."},{"t":"day","d":"Offset from the first day of the week."}]},"setTime":{"s":"Sets the time","y":"public DateTime DateTime::setTime\n    ( int $hour\n   , int $minute\n   [, int $second = 0\n  ] )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"hour","d":"Hour of the time."},{"t":"minute","d":"Minute of the time."},{"t":"second","d":"Second of the time."}]},"setTimestamp":{"s":"Sets the date and time based on an Unix timestamp","y":"public DateTime DateTime::setTimestamp\n    ( int $unixtimestamp\n   )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"unixtimestamp","d":"Unix timestamp representing the date."}]},"setTimezone":{"s":"Sets the time zone for the DateTime object","y":"public DateTime DateTime::setTimezone\n    ( DateTimeZone $timezone\n   )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"timezone","d":"A DateTimeZone object representing the\n      desired time zone."}]},"sub":{"s":"Subtracts an amount of days, months, years, hours, minutes and seconds from\n   a DateTime object","y":"public DateTime DateTime::sub\n    ( DateInterval $interval\n   )","p":[{"t":"object","d":"Procedural style only: A DateTime object\nreturned by date_create().\nThe function modifies this object."},{"t":"interval","d":"A DateInterval object"}]}},"ArrayObject":{"append":{"s":"Appends the value","y":"public void ArrayObject::append\n    ( mixed $value\n   )","p":[{"t":"value","d":"The value being appended."}]},"asort":{"s":"Sort the entries by value","y":"public void ArrayObject::asort\n    ( void\n   )","p":null},"__construct":{"s":"Construct a new array object","y":"","p":[{"t":"input","d":"The input parameter accepts an \n       array or an Object."},{"t":"flags","d":"Flags to control the behaviour of the ArrayObject object.\n       See ArrayObject::setFlags()."},{"t":"iterator_class","d":"Specify the class that will be used for iteration of the ArrayObject object."}]},"count":{"s":"Get the number of public properties in the ArrayObject","y":"public int ArrayObject::count\n    ( void\n   )","p":null},"exchangeArray":{"s":"Exchange the array for another one.","y":"public array ArrayObject::exchangeArray\n    ( mixed $input\n   )","p":[{"t":"input","d":"The new array or object to exchange with the current array."}]},"getArrayCopy":{"s":"Creates a copy of the ArrayObject.","y":"public array ArrayObject::getArrayCopy\n    ( void\n   )","p":null},"getFlags":{"s":"Gets the behavior flags.","y":"public int ArrayObject::getFlags\n    ( void\n   )","p":null},"getIterator":{"s":"Create a new iterator from an ArrayObject instance","y":"public ArrayIterator ArrayObject::getIterator\n    ( void\n   )","p":null},"getIteratorClass":{"s":"Gets the iterator classname for the ArrayObject.","y":"public string ArrayObject::getIteratorClass\n    ( void\n   )","p":null},"ksort":{"s":"Sort the entries by key","y":"public void ArrayObject::ksort\n    ( void\n   )","p":null},"natsort":{"s":"Sort entries using a &quot;natural order&quot; algorithm","y":"public void ArrayObject::natsort\n    ( void\n   )","p":null},"offsetExists":{"s":"Returns whether the requested index exists","y":"public bool ArrayObject::offsetExists\n    ( mixed $index\n   )","p":[{"t":"index","d":"The index being checked."}]},"offsetGet":{"s":"Returns the value at the specified index","y":"public mixed ArrayObject::offsetGet\n    ( mixed $index\n   )","p":[{"t":"index","d":"The index with the value."}]},"offsetSet":{"s":"Sets the value at the specified index to newval","y":"public void ArrayObject::offsetSet\n    ( mixed $index\n   , mixed $newval\n   )","p":[{"t":"index","d":"The index being set."},{"t":"newval","d":"The new value for the index."}]},"offsetUnset":{"s":"Unsets the value at the specified index","y":"public void ArrayObject::offsetUnset\n    ( mixed $index\n   )","p":[{"t":"index","d":"The index being unset."}]},"serialize":{"s":"Serialize an ArrayObject","y":"public string ArrayObject::serialize\n    ( void\n   )","p":null},"setFlags":{"s":"Sets the behavior flags.","y":"public void ArrayObject::setFlags\n    ( int $flags\n   )","p":[{"t":"flags","d":"The new ArrayObject behavior.\n       It takes on either a bitmask, or named constants. Using named\n       constants is strongly encouraged to ensure compatibility for future\n       versions."}]},"setIteratorClass":{"s":"Sets the iterator classname for the ArrayObject.","y":"public void ArrayObject::setIteratorClass\n    ( string $iterator_class\n   )","p":[{"t":"iterator_class","d":"The classname of the array iterator to use when iterating over this object."}]},"uasort":{"s":"Sort the entries with a user-defined comparison function and maintain key association","y":"public void ArrayObject::uasort\n    ( callable $cmp_function\n   )","p":[{"t":"cmp_function","d":"Function cmp_function should accept two\n       parameters which will be filled by pairs of entries.\n       The comparison function must return an integer less than, equal\n       to, or greater than zero if the first argument is considered to\n       be respectively less than, equal to, or greater than the\n       second."}]},"uksort":{"s":"Sort the entries by keys using a user-defined comparison function","y":"public void ArrayObject::uksort\n    ( callable $cmp_function\n   )","p":[{"t":"cmp_function","d":"The callback comparison function."}]},"unserialize":{"s":"Unserialize an ArrayObject","y":"public void ArrayObject::unserialize\n    ( string $serialized\n   )","p":[{"t":"serialized","d":"The serialized ArrayObject."}]}},"Directory":{"close":{"s":"Close directory handle","y":"public void Directory::close\n    ([ resource $dir_handle\n  ] )","p":null},"read":{"s":"Read entry from directory handle","y":"public string Directory::read\n    ([ resource $dir_handle\n  ] )","p":null},"rewind":{"s":"Rewind directory handle","y":"public void Directory::rewind\n    ([ resource $dir_handle\n  ] )","p":null}},"DirectoryIterator":{"__construct":{"s":"Constructs a new directory iterator from a path","y":"","p":[{"t":"path","d":"The path of the directory to traverse."}]},"current":{"s":"Return the current DirectoryIterator item.","y":"public DirectoryIterator DirectoryIterator::current\n    ( void\n   )","p":null},"getATime":{"s":"Get last access time of the current DirectoryIterator item","y":"public int DirectoryIterator::getATime\n    ( void\n   )","p":null},"getBasename":{"s":"Get base name of current DirectoryIterator item.","y":"public\n   string \n   DirectoryIterator::getBasename\n    ([ \n    string\n     $suffix\n   \n  ] )","p":[{"t":"suffix","d":"If the base name ends in suffix, \n       this will be cut."}]},"getCTime":{"s":"Get inode change time of the current DirectoryIterator item","y":"public int DirectoryIterator::getCTime\n    ( void\n   )","p":null},"getExtension":{"s":"Gets the file extension","y":"public string DirectoryIterator::getExtension\n    ( void\n   )","p":null},"getFilename":{"s":"Return file name of current DirectoryIterator item.","y":"public string DirectoryIterator::getFilename\n    ( void\n   )","p":null},"getGroup":{"s":"Get group for the current DirectoryIterator item","y":"public int DirectoryIterator::getGroup\n    ( void\n   )","p":null},"getInode":{"s":"Get inode for the current DirectoryIterator item","y":"public int DirectoryIterator::getInode\n    ( void\n   )","p":null},"getMTime":{"s":"Get last modification time of current DirectoryIterator item","y":"public int DirectoryIterator::getMTime\n    ( void\n   )","p":null},"getOwner":{"s":"Get owner of current DirectoryIterator item","y":"public int DirectoryIterator::getOwner\n    ( void\n   )","p":null},"getPath":{"s":"Get path of current Iterator item without filename","y":"public string DirectoryIterator::getPath\n    ( void\n   )","p":null},"getPathname":{"s":"Return path and file name of current DirectoryIterator item","y":"public string DirectoryIterator::getPathname\n    ( void\n   )","p":null},"getPerms":{"s":"Get the permissions of current DirectoryIterator item","y":"public int DirectoryIterator::getPerms\n    ( void\n   )","p":null},"getSize":{"s":"Get size of current DirectoryIterator item","y":"public int DirectoryIterator::getSize\n    ( void\n   )","p":null},"getType":{"s":"Determine the type of the current DirectoryIterator item","y":"public string DirectoryIterator::getType\n    ( void\n   )","p":null},"isDir":{"s":"Determine if current DirectoryIterator item is a directory","y":"public bool DirectoryIterator::isDir\n    ( void\n   )","p":null},"isDot":{"s":"Determine if current DirectoryIterator item is &#039;.&#039; or &#039;..&#039;","y":"public bool DirectoryIterator::isDot\n    ( void\n   )","p":null},"isExecutable":{"s":"Determine if current DirectoryIterator item is executable","y":"public bool DirectoryIterator::isExecutable\n    ( void\n   )","p":null},"isFile":{"s":"Determine if current DirectoryIterator item is a regular file","y":"public bool DirectoryIterator::isFile\n    ( void\n   )","p":null},"isLink":{"s":"Determine if current DirectoryIterator item is a symbolic link","y":"public bool DirectoryIterator::isLink\n    ( void\n   )","p":null},"isReadable":{"s":"Determine if current DirectoryIterator item can be read","y":"public bool DirectoryIterator::isReadable\n    ( void\n   )","p":null},"isWritable":{"s":"Determine if current DirectoryIterator item can be written to","y":"public bool DirectoryIterator::isWritable\n    ( void\n   )","p":null},"key":{"s":"Return the key for the current DirectoryIterator item","y":"public string  DirectoryIterator::key\n    ( void\n   )","p":null},"next":{"s":"Move forward to next DirectoryIterator item","y":"public void  DirectoryIterator::next\n    ( void\n   )","p":null},"rewind":{"s":"Rewind the DirectoryIterator back to the start","y":"public void DirectoryIterator::rewind\n    ( void\n   )","p":null},"seek":{"s":"Seek to a DirectoryIterator item","y":"public\n   void \n   DirectoryIterator::seek\n    ( int $position\n   )","p":[{"t":"position","d":"The zero-based numeric position to seek to."}]},"__toString":{"s":"Get file name as a string","y":"public\n   string \n   DirectoryIterator::__toString\n    ( void\n   )","p":null},"valid":{"s":"Check whether current DirectoryIterator position is a valid file","y":"public bool DirectoryIterator::valid\n    ( void\n   )","p":null}},"ArrayIterator":{"__construct":{"s":"Construct an ArrayIterator","y":"public ArrayIterator::__construct\n    ([ mixed $array = array()\n   [, int $flags = 0\n  ]] )","p":[{"t":"array","d":"The array or object to be iterated on."},{"t":"flags","d":"Flags to control the behaviour of the ArrayIterator object.\n       See ArrayIterator::setFlags()."}]},"append":{"s":"Append an element","y":"public void ArrayIterator::append\n    ( mixed $value\n   )","p":[{"t":"value","d":"The value to append."}]},"asort":{"s":"Sort array by values","y":"public void ArrayIterator::asort\n    ( void\n   )","p":null},"count":{"s":"Count elements","y":"public int ArrayIterator::count\n    ( void\n   )","p":null},"current":{"s":"Return current array entry","y":"public mixed ArrayIterator::current\n    ( void\n   )","p":null},"getArrayCopy":{"s":"Get array copy","y":"public array ArrayIterator::getArrayCopy\n    ( void\n   )","p":null},"getFlags":{"s":"Get flags","y":"public void ArrayIterator::getFlags\n    ( void\n   )","p":null},"key":{"s":"Return current array key","y":"public mixed ArrayIterator::key\n    ( void\n   )","p":null},"ksort":{"s":"Sort array by keys","y":"public void ArrayIterator::ksort\n    ( void\n   )","p":null},"natcasesort":{"s":"Sort an array naturally, case insensitive","y":"public void ArrayIterator::natcasesort\n    ( void\n   )","p":null},"natsort":{"s":"Sort an array naturally","y":"public void ArrayIterator::natsort\n    ( void\n   )","p":null},"next":{"s":"Move to next entry","y":"public void ArrayIterator::next\n    ( void\n   )","p":null},"offsetExists":{"s":"Check if offset exists","y":"public void ArrayIterator::offsetExists\n    ( string $index\n   )","p":[{"t":"index","d":"The offset being checked."}]},"offsetGet":{"s":"Get value for an offset","y":"public mixed ArrayIterator::offsetGet\n    ( string $index\n   )","p":[{"t":"index","d":"The offset to get the value from."}]},"offsetSet":{"s":"Set value for an offset","y":"public void ArrayIterator::offsetSet\n    ( string $index\n   , string $newval\n   )","p":[{"t":"index","d":"The index to set for."},{"t":"newval","d":"The new value to store at the index."}]},"offsetUnset":{"s":"Unset value for an offset","y":"public void ArrayIterator::offsetUnset\n    ( string $index\n   )","p":[{"t":"index","d":"The offset to unset."}]},"rewind":{"s":"Rewind array back to the start","y":"public void ArrayIterator::rewind\n    ( void\n   )","p":null},"seek":{"s":"Seek to position","y":"public void ArrayIterator::seek\n    ( int $position\n   )","p":[{"t":"position","d":"The position to seek to."}]},"serialize":{"s":"Serialize","y":"public string ArrayIterator::serialize\n    ( void\n   )","p":null},"setFlags":{"s":"Set behaviour flags","y":"public void ArrayIterator::setFlags\n    ( string $flags\n   )","p":[{"t":"flags","d":"A bitmask as follows:\n       \n        \n         0 = Properties of the object have their normal functionality\n         when accessed as list (var_dump, foreach, etc.).\n        \n        \n         1 = Array indices can be accessed as properties in read\/write."}]},"uasort":{"s":"User defined sort","y":"public void ArrayIterator::uasort\n    ( string $cmp_function\n   )","p":[{"t":"cmp_function","d":"The compare function used for the sort."}]},"uksort":{"s":"User defined sort","y":"public void ArrayIterator::uksort\n    ( string $cmp_function\n   )","p":[{"t":"cmp_function","d":"The compare function used for the sort."}]},"unserialize":{"s":"Unserialize","y":"public string ArrayIterator::unserialize\n    ( string $serialized\n   )","p":[{"t":"serialized","d":"The serialized ArrayIterator object to be unserialized."}]},"valid":{"s":"Check whether array contains more entries","y":"public bool ArrayIterator::valid\n    ( void\n   )","p":null}},"RegexIterator":{"accept":{"s":"Get accept status","y":"public bool RegexIterator::accept\n    ( void\n   )","p":null},"__construct":{"s":"Create a new RegexIterator","y":"","p":[{"t":"iterator","d":"The iterator to apply this regex filter to."},{"t":"regex","d":"The regular expression to match."},{"t":"mode","d":"Operation mode, see RegexIterator::setMode() for a list\n       of modes."},{"t":"flags","d":"Special flags, see RegexIterator::setFlags() for a list\n       of available flags."},{"t":"preg_flags","d":"The regular expression flags. These flags depend on the operation mode parameter:"}]},"getFlags":{"s":"Get flags","y":"public int RegexIterator::getFlags\n    ( void\n   )","p":null},"getMode":{"s":"Returns operation mode.","y":"public int RegexIterator::getMode\n    ( void\n   )","p":null},"getPregFlags":{"s":"Returns the regular expression flags.","y":"public int RegexIterator::getPregFlags\n    ( void\n   )","p":null},"getRegex":{"s":"Returns current regular expression","y":"public string RegexIterator::getRegex\n    ( void\n   )","p":null},"setFlags":{"s":"Sets the flags.","y":"public void RegexIterator::setFlags\n    ( int $flags\n   )","p":[{"t":"flags","d":"The flags to set, a bitmask of class constants."}]},"setMode":{"s":"Sets the operation mode.","y":"public void RegexIterator::setMode\n    ( int $mode\n   )","p":[{"t":"mode","d":"The operation mode."}]},"setPregFlags":{"s":"Sets the regular expression flags.","y":"public void RegexIterator::setPregFlags\n    ( int $preg_flags\n   )","p":[{"t":"preg_flags","d":"The regular expression flags. See RegexIterator::__construct()\n       for an overview of available flags."}]}},"Exception":{"__construct":{"s":"Construct the exception","y":"","p":[{"t":"message","d":"The Exception message to throw."},{"t":"code","d":"The Exception code."},{"t":"previous","d":"The previous exception used for the exception chaining."}]},"getMessage":{"s":"Gets the Exception message","y":"final public string Exception::getMessage\n    ( void\n   )","p":null},"getPrevious":{"s":"Returns previous Exception","y":"final public Exception Exception::getPrevious\n    ( void\n   )","p":null},"getCode":{"s":"Gets the Exception code","y":"final public mixed Exception::getCode\n    ( void\n   )","p":null},"getFile":{"s":"Gets the file in which the exception occurred","y":"final public string Exception::getFile\n    ( void\n   )","p":null},"getLine":{"s":"Gets the line in which the exception occurred","y":"final public int Exception::getLine\n    ( void\n   )","p":null},"getTrace":{"s":"Gets the stack trace","y":"final public array Exception::getTrace\n    ( void\n   )","p":null},"getTraceAsString":{"s":"Gets the stack trace as a string","y":"final public string Exception::getTraceAsString\n    ( void\n   )","p":null},"__toString":{"s":"String representation of the exception","y":"public string  Exception::__toString\n    ( void\n   )","p":null},"__clone":{"s":"Clone the exception","y":"final private void Exception::__clone\n    ( void\n   )","p":null}},"ErrorException":{"__construct":{"s":"Constructs the exception","y":"","p":[{"t":"message","d":"The Exception message to throw."},{"t":"code","d":"The Exception code."},{"t":"severity","d":"The severity level of the exception."},{"t":"filename","d":"The filename where the exception is thrown."},{"t":"lineno","d":"The line number where the exception is thrown."},{"t":"previous","d":"The previous exception used for the exception chaining."}]},"getSeverity":{"s":"Gets the exception severity","y":"final public int ErrorException::getSeverity\n    ( void\n   )","p":null}},"Closure":{"__construct":{"s":"Constructor that disallows instantiation","y":"private Closure::__construct\n    ( void\n   )","p":null},"bind":{"s":"Duplicates a closure with a specific bound object and class scope","y":"public static Closure Closure::bind\n    ( Closure $closure\n   , object $newthis\n   [, mixed $newscope\n    = &quot;static&quot;\n  ] )","p":[{"t":"closure","d":"The anonymous functions to bind."},{"t":"newthis","d":"The object to which the given anonymous function should be bound, or\n      NULL for the closure to be unbound."},{"t":"newscope","d":"The class scope to which associate the closure is to be associated, or\n      &#039;static&#039; to keep the current one. If an object is given, the type of the\n      object will be used instead. This determines the visibility of protected\n      and private methods of the bound object."}]},"bindTo":{"s":"Duplicates the closure with a new bound object and class scope","y":"public Closure Closure::bindTo\n    ( object $newthis\n   [, mixed $newscope\n    = &quot;static&quot;\n  ] )","p":[{"t":"newthis","d":"The object to which the given anonymous function should be bound, or\n      NULL for the closure to be unbound."},{"t":"newscope","d":"The class scope to which associate the closure is to be associated, or\n      &#039;static&#039; to keep the current one. If an object is given, the type of the\n      object will be used instead. This determines the visibility of protected\n      and private methods of the bound object."}]}},"DateTimeZone":{"__construct":{"s":"Creates new DateTimeZone object","y":"","p":[{"t":"timezone","d":"One of timezones."}]},"getLocation":{"s":"Returns location information for a timezone","y":"public array DateTimeZone::getLocation\n    ( void\n   )","p":[{"t":"object","d":"Procedural style only: A DateTimeZone object\nreturned by timezone_open()"}]},"getName":{"s":"Returns the name of the timezone","y":"public string DateTimeZone::getName\n    ( void\n   )","p":[{"t":"object","d":"The DateTimeZone for which to get a name."}]},"getOffset":{"s":"Returns the timezone offset from GMT","y":"public int DateTimeZone::getOffset\n    ( DateTime $datetime\n   )","p":[{"t":"object","d":"Procedural style only: A DateTimeZone object\nreturned by timezone_open()"},{"t":"datetime","d":"DateTime that contains the date\/time to compute the offset from."}]},"getTransitions":{"s":"Returns all transitions for the timezone","y":"public array DateTimeZone::getTransitions\n    ([ int $timestamp_begin\n   [, int $timestamp_end\n  ]] )","p":[{"t":"object","d":"Procedural style only: A DateTimeZone object\nreturned by timezone_open()"},{"t":"timestamp_begin","d":"Begin timestamp."},{"t":"timestamp_end","d":"End timestamp."}]},"listAbbreviations":{"s":"Returns associative array containing dst, offset and the timezone name","y":"public static array DateTimeZone::listAbbreviations\n    ( void\n   )","p":null},"listIdentifiers":{"s":"Returns a numerically indexed array containing all defined timezone identifiers","y":"public static array DateTimeZone::listIdentifiers\n    ([ int $what = DateTimeZone::ALL\n   [, string $country = NULL\n  ]] )","p":[{"t":"what","d":"One of DateTimeZone class constants."},{"t":"country","d":"A two-letter ISO 3166-1 compatible country code."}]}},"DateInterval":{"__construct":{"s":"Creates a new DateInterval object","y":"","p":[{"t":"interval_spec","d":"An interval specification."}]},"createFromDateString":{"s":"Sets up a DateInterval from the relative parts of the string","y":"public static DateInterval DateInterval::createFromDateString\n    ( string $time\n   )","p":[{"t":"time","d":"A date with relative parts. Specifically, the\n       relative formats\n       supported by the parser used for strtotime() and\n       DateTime will be used to construct the\n       DateInterval."}]},"format":{"s":"Formats the interval","y":"public string DateInterval::format\n    ( string $format\n   )","p":[{"t":"format","d":"The following characters are recognized in the\n         format parameter string.\n         Each format character must be prefixed by a percent sign\n         (%).\n        \n        \n         \n          \n           format character\n           Description\n           Example values\n          \n\n         \n\n         \n          \n           %\n           Literal %\n           %\n          \n\n          \n           Y\n           Years, numeric, at least 2 digits with leading 0\n           01, 03\n          \n\n          \n           y\n           Years, numeric\n           1, 3\n          \n\n          \n           M\n           Months, numeric, at least 2 digits with leading 0\n           01, 03, 12\n          \n\n          \n           m\n           Months, numeric\n           1, 3, 12\n          \n\n          \n           D\n           Days, numeric, at least 2 digits with leading 0\n           01, 03, 31\n          \n\n          \n           d\n           Days, numeric\n           1, 3, 31\n          \n\n          \n           a\n           Total number of days as a result of a DateTime::diff() or (unknown) otherwise\n           4, 18, 8123\n          \n\n          \n           H\n           Hours, numeric, at least 2 digits with leading 0\n           01, 03, 23\n          \n\n          \n           h\n           Hours, numeric\n           1, 3, 23\n          \n\n          \n           I\n           Minutes, numeric, at least 2 digits with leading 0\n           01, 03, 59\n          \n\n          \n           i\n           Minutes, numeric\n           1, 3, 59\n          \n\n          \n           S\n           Seconds, numeric, at least 2 digits with leading 0\n           01, 03, 57\n          \n\n          \n           s\n           Seconds, numeric\n           1, 3, 57\n          \n\n          \n           R\n           Sign &quot;-&quot; when negative, &quot;+&quot; when positive\n           -, +\n          \n\n          \n           r\n           Sign &quot;-&quot; when negative, empty when positive\n           -,"}]}},"DatePeriod":{"__construct":{"s":"Creates a new DatePeriod object","y":"","p":[{"t":"start","d":"The start date of the period."},{"t":"interval","d":"The interval between recurrences within the period."},{"t":"recurrences","d":"The number of recurrences."},{"t":"end","d":"The end date of the period."},{"t":"isostr","d":"An ISO 8601 repeating interval specification."},{"t":"options","d":"Can be set to DatePeriod::EXCLUDE_START_DATE to\n       exclude the start date from the set of recurring dates within the\n       period."}]}},"LibXMLError":[],"DOMException":[],"LogicException":[],"IteratorIterator":{"__construct":{"s":"Create an iterator from anything that is traversable","y":"public IteratorIterator::__construct\n    ( Traversable $iterator\n   )","p":[{"t":"iterator","d":"The traversable iterator."}]},"current":{"s":"Get the current value","y":"public mixed IteratorIterator::current\n    ( void\n   )","p":null},"getInnerIterator":{"s":"Get the inner iterator","y":"public Traversable IteratorIterator::getInnerIterator\n    ( void\n   )","p":null},"key":{"s":"Get the key of the current element","y":"public scalar IteratorIterator::key\n    ( void\n   )","p":null},"next":{"s":"Forward to the next element","y":"public void IteratorIterator::next\n    ( void\n   )","p":null},"rewind":{"s":"Rewind to the first element","y":"public void IteratorIterator::rewind\n    ( void\n   )","p":null},"valid":{"s":"Checks if the iterator is valid","y":"public bool IteratorIterator::valid\n    ( void\n   )","p":null}},"FilterIterator":{"accept":{"s":"Check whether the current element of the iterator is acceptable","y":"public\n   abstract\n   bool FilterIterator::accept\n    ( void\n   )","p":null},"__construct":{"s":"Construct a filterIterator","y":"public\n   FilterIterator::__construct\n    ( Iterator $iterator\n   )","p":[{"t":"iterator","d":"The iterator that is being filtered."}]},"current":{"s":"Get the current element value","y":"public mixed FilterIterator::current\n    ( void\n   )","p":null},"getInnerIterator":{"s":"Get the inner iterator","y":"public Iterator FilterIterator::getInnerIterator\n    ( void\n   )","p":null},"key":{"s":"Get the current key","y":"public mixed FilterIterator::key\n    ( void\n   )","p":null},"next":{"s":"Move the iterator forward","y":"public void FilterIterator::next\n    ( void\n   )","p":null},"rewind":{"s":"Rewind the iterator","y":"public void FilterIterator::rewind\n    ( void\n   )","p":null},"valid":{"s":"Check whether the current element is valid","y":"public bool FilterIterator::valid\n    ( void\n   )","p":null}},"XMLReader":{"close":{"s":"Close the XMLReader input","y":"public bool XMLReader::close\n    ( void\n   )","p":null},"expand":{"s":"Returns a copy of the current node as a DOM object","y":"public\n   DOMNode \n   XMLReader::expand\n    ([ DOMNode $basenode\n  ] )","p":null},"getAttribute":{"s":"Get the value of a named attribute","y":"public\n   string \n   XMLReader::getAttribute\n    ( string $name\n   )","p":[{"t":"name","d":"The name of the attribute."}]},"getAttributeNo":{"s":"Get the value of an attribute by index","y":"public\n   string \n   XMLReader::getAttributeNo\n    ( int $index\n   )","p":[{"t":"index","d":"The position of the attribute."}]},"getAttributeNs":{"s":"Get the value of an attribute by localname and URI","y":"public string XMLReader::getAttributeNs\n    ( string $localName\n   , string $namespaceURI\n   )","p":[{"t":"localName","d":"The local name."},{"t":"namespaceURI","d":"The namespace URI."}]},"getParserProperty":{"s":"Indicates if specified property has been set","y":"public bool XMLReader::getParserProperty\n    ( int $property\n   )","p":[{"t":"property","d":"One of the parser option \n       constants."}]},"isValid":{"s":"Indicates if the parsed document is valid","y":"public bool XMLReader::isValid\n    ( void\n   )","p":null},"lookupNamespace":{"s":"Lookup namespace for a prefix","y":"public\n   bool \n   XMLReader::lookupNamespace\n    ( string $prefix\n   )","p":[{"t":"prefix","d":"String containing the prefix."}]},"moveToAttribute":{"s":"Move cursor to a named attribute","y":"public\n   bool \n   XMLReader::moveToAttribute\n    ( string $name\n   )","p":[{"t":"name","d":"The name of the attribute."}]},"moveToAttributeNo":{"s":"Move cursor to an attribute by index","y":"public\n   bool \n   XMLReader::moveToAttributeNo\n    ( int $index\n   )","p":[{"t":"index","d":"The position of the attribute."}]},"moveToAttributeNs":{"s":"Move cursor to a named attribute","y":"public\n   bool \n   XMLReader::moveToAttributeNs\n    ( string $localName\n   , string $namespaceURI\n   )","p":[{"t":"localName","d":"The local name."},{"t":"namespaceURI","d":"The namespace URI."}]},"moveToElement":{"s":"Position cursor on the parent Element of current Attribute","y":"public bool XMLReader::moveToElement\n    ( void\n   )","p":null},"moveToFirstAttribute":{"s":"Position cursor on the first Attribute","y":"public bool XMLReader::moveToFirstAttribute\n    ( void\n   )","p":null},"moveToNextAttribute":{"s":"Position cursor on the next Attribute","y":"public bool XMLReader::moveToNextAttribute\n    ( void\n   )","p":null},"next":{"s":"Move cursor to next node skipping all subtrees","y":"public\n   bool \n   XMLReader::next\n    ([ string $localname\n  ] )","p":[{"t":"localname","d":"The name of the next node to move to."}]},"open":{"s":"Set the URI containing the XML to parse","y":"public\n   bool \n   XMLReader::open\n    ( string $URI\n   [, string $encoding\n   [, int $options = 0\n  ]] )","p":[{"t":"URI","d":"URI pointing to the document."},{"t":"encoding","d":"The document encoding or NULL."},{"t":"options","d":"A bitmask of the LIBXML_* \n       constants."}]},"read":{"s":"Move to next node in document","y":"public bool XMLReader::read\n    ( void\n   )","p":null},"readInnerXML":{"s":"Retrieve XML from current node","y":"public string XMLReader::readInnerXML\n    ( void\n   )","p":null},"readOuterXML":{"s":"Retrieve XML from current node, including it self","y":"public string XMLReader::readOuterXML\n    ( void\n   )","p":null},"readString":{"s":"Reads the contents of the current node as a string","y":"public string XMLReader::readString\n    ( void\n   )","p":null},"setParserProperty":{"s":"Set parser options","y":"public\n   bool \n   XMLReader::setParserProperty\n    ( int $property\n   , bool $value\n   )","p":[{"t":"property","d":"One of the parser option \n       constants."},{"t":"value","d":"If set to TRUE the option will be enabled otherwise will \n       be disabled."}]},"setRelaxNGSchema":{"s":"Set the filename or URI for a RelaxNG Schema","y":"public\n   bool \n   XMLReader::setRelaxNGSchema\n    ( string $filename\n   )","p":[{"t":"filename","d":"filename or URI pointing to a RelaxNG Schema."}]},"setRelaxNGSchemaSource":{"s":"Set the data containing a RelaxNG Schema","y":"public\n   bool \n   XMLReader::setRelaxNGSchemaSource\n    ( string $source\n   )","p":[{"t":"source","d":"String containing the RelaxNG Schema."}]},"setSchema":{"s":"Validate document against XSD","y":"public bool XMLReader::setSchema\n    ( string $filename\n   )","p":[{"t":"filename","d":"The filename of the XSD schema."}]},"XML":{"s":"Set the data containing the XML to parse","y":"public\n   bool \n   XMLReader::xml\n    ( string $source\n   [, string $encoding\n   [, int $options = 0\n  ]] )","p":[{"t":"source","d":"String containing the XML to be parsed."},{"t":"encoding","d":"The document encoding or NULL."},{"t":"options","d":"A bitmask of the LIBXML_* \n       constants."}]}},"XMLWriter":[],"ZipArchive":{"addEmptyDir":{"s":"Add a new directory","y":"bool ZipArchive::addEmptyDir\n    ( string $dirname\n   )","p":[{"t":"dirname","d":"The directory to add."}]},"addFile":{"s":"Adds a file to a ZIP archive from the given path","y":"bool ZipArchive::addFile\n    ( string $filename\n   [, string $localname = NULL\n   [, int $start = 0\n   [, int $length = 0\n  ]]] )","p":[{"t":"filename","d":"The path to the file to add."},{"t":"localname","d":"If supplied, this is the local name inside the ZIP archive that will override the filename."},{"t":"start","d":"This parameter is not used but is required to extend ZipArchive."},{"t":"length","d":"This parameter is not used but is required to extend ZipArchive."}]},"addFromString":{"s":"Add a file to a ZIP archive using its contents","y":"bool ZipArchive::addFromString\n    ( string $localname\n   , string $contents\n   )","p":[{"t":"localname","d":"The name of the entry to create."},{"t":"contents","d":"The contents to use to create the entry. It is used in a binary\n       safe mode."}]},"addGlob":{"s":"Add files from a directory by glob pattern","y":"bool ZipArchive::addGlob\n    ( string $pattern\n   [, int $flags = 0\n   [, array $options = array()\n  ]] )","p":[{"t":"pattern","d":"A glob() pattern against which files will be matched."},{"t":"flags","d":"A bit mask of glob() flags."},{"t":"options","d":"An associative array of options. Available options are:\n      \n       \n        \n         &quot;add_path&quot;"}]},"addPattern":{"s":"Add files from a directory by PCRE pattern","y":"bool ZipArchive::addPattern\n    ( string $pattern\n   [, string $path = &quot;.&quot;\n   [, array $options = array()\n  ]] )","p":[{"t":"pattern","d":"A PCRE pattern against which files will be matched."},{"t":"path","d":"The directory that will be scanned. Defaults to the current working directory."},{"t":"options","d":"An associative array of options accepted by ZipArchive::addGlob()."}]},"close":{"s":"Close the active archive (opened or newly created)","y":"bool ZipArchive::close\n    ( void\n   )","p":null},"deleteIndex":{"s":"delete an entry in the archive using its index","y":"bool ZipArchive::deleteIndex\n    ( int $index\n   )","p":[{"t":"index","d":"Index of the entry to delete."}]},"deleteName":{"s":"delete an entry in the archive using its name","y":"bool ZipArchive::deleteName\n    ( string $name\n   )","p":[{"t":"name","d":"Name of the entry to delete."}]},"extractTo":{"s":"Extract the archive contents","y":"bool ZipArchive::extractTo\n    ( string $destination\n   [, mixed $entries\n  ] )","p":[{"t":"destination","d":"Location where to extract the files."},{"t":"entries","d":"The entries to extract. It accepts either a single entry name or\n       an array of names."}]},"getArchiveComment":{"s":"Returns the Zip archive comment","y":"string ZipArchive::getArchiveComment\n    ([ int $flags\n  ] )","p":[{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       comment is returned."}]},"getCommentIndex":{"s":"Returns the comment of an entry using the entry index","y":"string ZipArchive::getCommentIndex\n    ( int $index\n   [, int $flags\n  ] )","p":[{"t":"index","d":"Index of the entry"},{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       comment is returned."}]},"getCommentName":{"s":"Returns the comment of an entry using the entry name","y":"string ZipArchive::getCommentName\n    ( string $name\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Name of the entry"},{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       comment is returned."}]},"getExternalAttributesIndex":{"s":"Retrieve the external attributes of an entry defined by its index","y":"bool \n   ZipArchive::GetExternalAttributesIndex\n    ( int $index\n   , int &$opsys\n   , int &$attr\n   [, int $flags\n  ] )","p":[{"t":"index","d":"Index of the entry."},{"t":"opsys","d":"On success, receive the operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"On success, receive the external attributes. Value depends on operating system."},{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       attributes are returned."}]},"getExternalAttributesName":{"s":"Retrieve the external attributes of an entry defined by its name","y":"bool \n   ZipArchive::getExternalAttributesName\n    ( string $name\n   , int &$opsys\n   , int &$attr\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Name of the entry."},{"t":"opsys","d":"On success, receive the operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"On success, receive the external attributes. Value depends on operating system."},{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       attributes are returned."}]},"getFromIndex":{"s":"Returns the entry contents using its index","y":"string ZipArchive::getFromIndex\n    ( int $index\n   [, int $length = 0\n   [, int $flags\n  ]] )","p":[{"t":"index","d":"Index of the entry"},{"t":"length","d":"The length to be read from the entry. If 0, then the\n       entire entry is read."},{"t":"flags","d":"The flags to use to open the archive. the following values may\n       be ORed to it.\n       \n        \n         \n          ZipArchive::FL_UNCHANGED"}]},"getFromName":{"s":"Returns the entry contents using its name","y":"string ZipArchive::getFromName\n    ( string $name\n   [, int $length = 0\n   [, int $flags\n  ]] )","p":[{"t":"name","d":"Name of the entry"},{"t":"length","d":"The length to be read from the entry. If 0, then the\n       entire entry is read."},{"t":"flags","d":"The flags to use to open the archive. the following values may\n       be ORed to it.\n       \n        \n         \n          ZipArchive::FL_UNCHANGED"}]},"getNameIndex":{"s":"Returns the name of an entry using its index","y":"string ZipArchive::getNameIndex\n    ( int $index\n   [, int $flags\n  ] )","p":[{"t":"index","d":"Index of the entry."},{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       name is returned."}]},"getStatusString":{"s":"Returns the status error message, system and\/or zip messages","y":"string ZipArchive::getStatusString\n    ( void\n   )","p":null},"getStream":{"s":"Get a file handler to the entry defined by its name (read only).","y":"resource ZipArchive::getStream\n    ( string $name\n   )","p":[{"t":"name","d":"The name of the entry to use."}]},"locateName":{"s":"Returns the index of the entry in the archive","y":"int ZipArchive::locateName\n    ( string $name\n   [, int $flags\n  ] )","p":[{"t":"name","d":"The name of the entry to look up"},{"t":"flags","d":"The flags are specified by ORing the following values,\n       or 0 for none of them.\n       \n        \n         \n          ZipArchive::FL_NOCASE"}]},"open":{"s":"Open a ZIP file archive","y":"mixed ZipArchive::open\n    ( string $filename\n   [, int $flags\n  ] )","p":[{"t":"filename","d":"The file name of the ZIP archive to open."},{"t":"flags","d":"The mode to use to open the archive.\n       \n        \n         \n          ZipArchive::OVERWRITE"}]},"renameIndex":{"s":"Renames an entry defined by its index","y":"bool ZipArchive::renameIndex\n    ( int $index\n   , string $newname\n   )","p":[{"t":"index","d":"Index of the entry to rename."},{"t":"newname","d":"New name."}]},"renameName":{"s":"Renames an entry defined by its name","y":"bool ZipArchive::renameName\n    ( string $name\n   , string $newname\n   )","p":[{"t":"name","d":"Name of the entry to rename."},{"t":"newname","d":"New name."}]},"setArchiveComment":{"s":"Set the comment of a ZIP archive","y":"bool ZipArchive::setArchiveComment\n    ( string $comment\n   )","p":[{"t":"comment","d":"The contents of the comment."}]},"setCommentIndex":{"s":"Set the comment of an entry defined by its index","y":"bool ZipArchive::setCommentIndex\n    ( int $index\n   , string $comment\n   )","p":[{"t":"index","d":"Index of the entry."},{"t":"comment","d":"The contents of the comment."}]},"setCommentName":{"s":"Set the comment of an entry defined by its name","y":"bool ZipArchive::setCommentName\n    ( string $name\n   , string $comment\n   )","p":[{"t":"name","d":"Name of the entry."},{"t":"comment","d":"The contents of the comment."}]},"setExternalAttributesIndex":{"s":"Set the external attributes of an entry defined by its index","y":"bool \n   ZipArchive::setExternalAttributesIndex\n    ( int $index\n   , int $opsys\n   , int $attr\n   [, int $flags\n  ] )","p":[{"t":"index","d":"Index of the entry."},{"t":"opsys","d":"The operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"The external attributes. Value depends on operating system."},{"t":"flags","d":"Optional flags. Currently unused."}]},"setExternalAttributesName":{"s":"Set the external attributes of an entry defined by its name","y":"bool \n   ZipArchive::setExternalAttributesName\n    ( string $name\n   , int $opsys\n   , int $attr\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Name of the entry."},{"t":"opsys","d":"The operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"The external attributes. Value depends on operating system."},{"t":"flags","d":"Optional flags. Currently unused."}]},"statIndex":{"s":"Get the details of an entry defined by its index.","y":"array ZipArchive::statIndex\n    ( int $index\n   [, int $flags\n  ] )","p":[{"t":"index","d":"Index of the entry"},{"t":"flags","d":"ZipArchive::FL_UNCHANGED may be ORed to it to request\n       information  about  the  original  file  in  the archive,\n       ignoring any changes made."}]},"statName":{"s":"Get the details of an entry defined by its name.","y":"array ZipArchive::statName\n    ( string $name\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Name of the entry"},{"t":"flags","d":"The flags argument specifies how the name lookup should be done.\n       Also, ZipArchive::FL_UNCHANGED may be ORed to it to request\n       information  about  the  original  file  in  the archive,\n       ignoring any changes made.\n       \n        \n         \n          ZipArchive::FL_NOCASE"}]},"unchangeAll":{"s":"Undo all changes done in the archive","y":"bool ZipArchive::unchangeAll\n    ( void\n   )","p":null},"unchangeArchive":{"s":"Revert all global changes done in the archive.","y":"bool ZipArchive::unchangeArchive\n    ( void\n   )","p":null},"unchangeIndex":{"s":"Revert all changes done to an entry at the given index","y":"bool ZipArchive::unchangeIndex\n    ( int $index\n   )","p":[{"t":"index","d":"Index of the entry."}]},"unchangeName":{"s":"Revert all changes done to an entry with the given name.","y":"bool ZipArchive::unchangeName\n    ( string $name\n   )","p":[{"t":"name","d":"Name of the entry."}]}}}