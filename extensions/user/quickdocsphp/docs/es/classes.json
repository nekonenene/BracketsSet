{"DateTime":{"add":{"s":"A\u00f1ade una cantidad de d\u00edas, meses, a\u00f1os, horas, minutos y segundos al objeto\n   DateTime","y":"public DateTime DateTime::add\n    ( DateInterval $interval\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"interval","d":"Un objeto DateInterval"}]},"__construct":{"s":"Devuelve un nuevo objeto DateTime","y":"","p":[{"t":"time","d":"Una cadena de fecha\/hora. Los formatos v\u00e1lidos son explicados en Formatos de fecha y hora."},{"t":"timezone","d":"Un objeto DateTimeZone que representa la\n      zona horaria de $time."}]},"createFromFormat":{"s":"Devuelve un nuevo objeto DateTime formateado seg\u00fan el formato especificado","y":"public static DateTime DateTime::createFromFormat\n    ( string $format\n   , string $time\n   [, DateTimeZone $timezone\n  ] )","p":[{"t":"format","d":"El formato en el que deber\u00eda estar lo pasado en string. V\u00e9ase las\n      opciones de formateo m\u00e1s abajo. En la mayor\u00eda de los casos se pueden usar las mismas letras\n      que para date()."},{"t":"time","d":"Una cadena que representa la hora."},{"t":"timezone","d":"Un objeto DateTimeZone que representa la\n      zona horaria deseada."}]},"getLastErrors":{"s":"Devuelve las advertencias y los errores","y":"public static array DateTime::getLastErrors\n    ( void\n   )","p":null},"modify":{"s":"Altera la marca de tiempo","y":"public DateTime DateTime::modify\n    ( string $modify\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"modify","d":"Una cadena de fecha\/hora. Los formatos v\u00e1lidos son explicados en Formatos de fecha y hora."}]},"__set_state":{"s":"El gestor __set_state","y":"public static DateTime DateTime::__set_state\n    ( array $array\n   )","p":[{"t":"array","d":"Matriz de inicializaci\u00f3n."}]},"setDate":{"s":"Establece la fecha","y":"public DateTime DateTime::setDate\n    ( int $year\n   , int $month\n   , int $day\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"year","d":"A\u00f1o de la fecha."},{"t":"month","d":"Mes de la fecha."},{"t":"day","d":"D\u00eda de la fecha."}]},"setISODate":{"s":"Establece la fecha ISO","y":"public DateTime DateTime::setISODate\n    ( int $year\n   , int $week\n   [, int $day = 1\n  ] )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"year","d":"A\u00f1o de la fecha."},{"t":"week","d":"Semana de la fecha."},{"t":"day","d":"\u00cdndice del primer d\u00eda de la semana."}]},"setTime":{"s":"Establece la hora","y":"public DateTime DateTime::setTime\n    ( int $hour\n   , int $minute\n   [, int $second = 0\n  ] )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"hour","d":"Hora del momento."},{"t":"minute","d":"Minuto del momento."},{"t":"second","d":"Segundo del momento."}]},"setTimestamp":{"s":"Establece la fecha y la hora basadas en una fecha Unix","y":"public DateTime DateTime::setTimestamp\n    ( int $unixtimestamp\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"unixtimestamp","d":"La marca de tiempo Unix que representa la fecha."}]},"setTimezone":{"s":"Establece la zona horaria para el objeto DateTime","y":"public DateTime DateTime::setTimezone\n    ( DateTimeZone $timezone\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"timezone","d":"Un objeto DateTimeZone que representa la\n      zona horaria deseada."}]},"sub":{"s":"Sustrae una cantidad de d\u00edas, meses, a\u00f1os, horas, minutos y segundos de un objeto\n   DateTime","y":"public DateTime DateTime::sub\n    ( DateInterval $interval\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTime\n devuelto por date_create().\n La funci\u00f3n modifica este objeto."},{"t":"interval","d":"Un objeto DateInterval"}]}},"ArrayObject":{"append":{"s":"A\u00f1ade un valor","y":"public void ArrayObject::append\n    ( mixed $value\n   )","p":[{"t":"value","d":"El valor a ser a\u00f1adido."}]},"asort":{"s":"Ordena las entradas por valor","y":"public void ArrayObject::asort\n    ( void\n   )","p":null},"__construct":{"s":"Construir un nuevo objeto Array","y":"","p":[{"t":"input","d":"Este par\u00e1metro de input (entrada) acepta un \n       array o un objeto."},{"t":"flags","d":"Flags para controlar el comportamiento del objeto ArrayObject."},{"t":"iterator_class","d":"Especifica la clase que va a ser usada para la iteraci\u00f3n del objeto ArrayObject.\n       ArrayIterator es la clase usada por omisi\u00f3n."}]},"count":{"s":"Obtener el n\u00famero de propiedades p\u00fablicas en la clase ArrayObject","y":"public int ArrayObject::count\n    ( void\n   )","p":null},"exchangeArray":{"s":"Intercambia el array por otro","y":"public array ArrayObject::exchangeArray\n    ( mixed $input\n   )","p":[{"t":"input","d":"El nuevo array u objeto a ser intercambiado con el array actual."}]},"getArrayCopy":{"s":"Crea una copia de la clase ArrayObject","y":"public array ArrayObject::getArrayCopy\n    ( void\n   )","p":null},"getFlags":{"s":"Obtiene las flags de comportamiento","y":"public int ArrayObject::getFlags\n    ( void\n   )","p":null},"getIterator":{"s":"Crear un nuevo iterador desde una instancia ArrayObject","y":"public ArrayIterator ArrayObject::getIterator\n    ( void\n   )","p":null},"getIteratorClass":{"s":"Obtiene el nombre de clase iterador para ArrayObject","y":"public string ArrayObject::getIteratorClass\n    ( void\n   )","p":null},"ksort":{"s":"Ordena las entradas por clave","y":"public void ArrayObject::ksort\n    ( void\n   )","p":null},"natsort":{"s":"Ordena entradas usando un algoritmo de orden natural","y":"public void ArrayObject::natsort\n    ( void\n   )","p":null},"offsetExists":{"s":"Devuelve si el \u00edndice solicitado existe","y":"public bool ArrayObject::offsetExists\n    ( mixed $index\n   )","p":[{"t":"index","d":"El \u00edndice a ser comprobado."}]},"offsetGet":{"s":"Devuelve el valor del \u00edndice especificado","y":"public mixed ArrayObject::offsetGet\n    ( mixed $index\n   )","p":[{"t":"index","d":"El \u00edndice con el valor."}]},"offsetSet":{"s":"Establece el valor en el \u00edndice especificado","y":"public void ArrayObject::offsetSet\n    ( mixed $index\n   , mixed $newval\n   )","p":[{"t":"index","d":"El \u00edndice a ser establecido."},{"t":"newval","d":"El nuevo valor para el index."}]},"offsetUnset":{"s":"Destruye el valor para el \u00edndice especificado","y":"public void ArrayObject::offsetUnset\n    ( mixed $index\n   )","p":[{"t":"index","d":"El \u00edndice a ser destruido."}]},"serialize":{"s":"Serializa un ArrayObject","y":"public void ArrayObject::serialize\n    ( void\n   )","p":null},"setFlags":{"s":"Establece las flags de comportamiento","y":"public void ArrayObject::setFlags\n    ( int $flags\n   )","p":[{"t":"flags","d":"El nuevo comportamiento de ArrayObject.\n       Se necesita una m\u00e1scara de bits, o constantes con nombre. El uso \n       de constantes con nombre es bastante recomendable para asegurar la \n       compatibilidad con versiones futuras."}]},"setIteratorClass":{"s":"Establece el nombre de clase iterador para ArrayObject","y":"public void ArrayObject::setIteratorClass\n    ( string $iterator_class\n   )","p":[{"t":"iterator_class","d":"El nombre de clase de el array iterador a usar cuando se itera sobre este objeto."}]},"uasort":{"s":"Ordena las entradas con una funci\u00f3n de comparaci\u00f3n definida por el usuario y mantiene asociaci\u00f3n de claves","y":"public void ArrayObject::uasort\n    ( callable $cmp_function\n   )","p":[{"t":"cmp_function","d":"La funci\u00f3n cmp_function acepta 2 par\u00e1metros \n       que ser\u00e1n llenados por pares de entradas.\n       La funci\u00f3n de comparaci\u00f3n debe devolver un integer menor que, igual a, \n       o mayor que cero si el primer argumento es menor que, igual a, o \n       mayor que el segundo."}]},"uksort":{"s":"Ordena las entradas por clave usando una funci\u00f3n de comparaci\u00f3n definida por el usuario","y":"public void ArrayObject::uksort\n    ( callable $cmp_function\n   )","p":[{"t":"cmp_function","d":"La funci\u00f3n de devoluci\u00f3n de llamada de comparaci\u00f3n."}]},"unserialize":{"s":"Deserializar el objeto ArrayObject","y":"public void ArrayObject::unserialize\n    ( string $serialized\n   )","p":[{"t":"serialized","d":"El objeto ArrayObject serializado."}]}},"Directory":{"close":{"s":"Cierra un gestor de directorio","y":"public void Directory::close\n    ([ resource $dir_handle\n  ] )","p":null},"read":{"s":"Lee una entrada desde el controlador de directorio","y":"public string Directory::read\n    ([ resource $dir_handle\n  ] )","p":null},"rewind":{"s":"Rebobina el manejador de directorio","y":"public void Directory::rewind\n    ([ resource $dir_handle\n  ] )","p":null}},"DirectoryIterator":{"__construct":{"s":"Construye un iterador nuevo directorio de una ruta","y":"","p":[{"t":"path","d":"La ruta del directorio a recorrer."}]},"current":{"s":"Devuelve el elemento actual del DirectoryIterator","y":"public DirectoryIterator DirectoryIterator::current\n    ( void\n   )","p":null},"getATime":{"s":"Obtener el \u00faltimo acceso del elemento actual DirectoryIterator","y":"public int DirectoryIterator::getATime\n    ( void\n   )","p":null},"getBasename":{"s":"Obtener el nombre base del elemento actual DirectoryIterator","y":"public\n   string \n   DirectoryIterator::getBasename\n    ([ \n    string\n     $suffix\n   \n  ] )","p":[{"t":"suffix","d":"Si el nombre base termina en suffix, \n       este ser\u00e1 cortado."}]},"getCTime":{"s":"Obtiene el cambio de tiempo del inodo para el elemento actual DirectoryIterator","y":"public int DirectoryIterator::getCTime\n    ( void\n   )","p":null},"getExtension":{"s":"Obtiene la extensi\u00f3n de un fichero","y":"public string DirectoryIterator::getExtension\n    ( void\n   )","p":null},"getFilename":{"s":"Devuelve el nombre del fichero del elemento actual DirectoryIterator","y":"public string DirectoryIterator::getFilename\n    ( void\n   )","p":null},"getGroup":{"s":"Obtiene el grupo para el elemento actual DirectoryIterator","y":"public int DirectoryIterator::getGroup\n    ( void\n   )","p":null},"getInode":{"s":"Obtiene el inodo para el elemento actual DirectoryIterator","y":"public int DirectoryIterator::getInode\n    ( void\n   )","p":null},"getMTime":{"s":"Obtiene la \u00faltima modificaci\u00f3n para el elemento actual DirectoryIterator","y":"public int DirectoryIterator::getMTime\n    ( void\n   )","p":null},"getOwner":{"s":"Obtiene el due\u00f1o del elemento actual DirectoryIterator","y":"public int DirectoryIterator::getOwner\n    ( void\n   )","p":null},"getPath":{"s":"Obtiene la ruta del elemento iterador actual sin nombre de fichero","y":"public string DirectoryIterator::getPath\n    ( void\n   )","p":null},"getPathname":{"s":"Devuelve la ruta y nombre de fichnero del elemento actual DirectoryIterator","y":"public string DirectoryIterator::getPathname\n    ( void\n   )","p":null},"getPerms":{"s":"Obtiene los permisos del elemento actual DirectoryIterator","y":"public int DirectoryIterator::getPerms\n    ( void\n   )","p":null},"getSize":{"s":"obtiene el tama\u00f1o de el elemento actual DirectoryIterator","y":"public int DirectoryIterator::getSize\n    ( void\n   )","p":null},"getType":{"s":"Determina el tipo del elemento actual DirectoryIterator","y":"public string DirectoryIterator::getType\n    ( void\n   )","p":null},"isDir":{"s":"Determina si el elemento actual DirectoryIterator es un directorio","y":"public bool DirectoryIterator::isDir\n    ( void\n   )","p":null},"isDot":{"s":"Determina si el elemento actual DirectoryIterator es &#039;.&#039; o &#039;..&#039;","y":"public bool DirectoryIterator::isDot\n    ( void\n   )","p":null},"isExecutable":{"s":"Determina si el emento actual DirectoryIterator es ejecutable","y":"public bool DirectoryIterator::isExecutable\n    ( void\n   )","p":null},"isFile":{"s":"Determina si el elemento actual DirectoryIterator es un fichero","y":"public bool DirectoryIterator::isFile\n    ( void\n   )","p":null},"isLink":{"s":"Determina si el elemento actual DirectoryIterator es un enlace simb\u00f3lico","y":"public bool DirectoryIterator::isLink\n    ( void\n   )","p":null},"isReadable":{"s":"Determina si el elemento actual DirectoryIterator puede ser le\u00eddo","y":"public bool DirectoryIterator::isReadable\n    ( void\n   )","p":null},"isWritable":{"s":"Determina si el elemento actual DirectoryIterator se puede escribir","y":"public bool DirectoryIterator::isWritable\n    ( void\n   )","p":null},"key":{"s":"Devuelve la clave del elemento actual DirectoryIterator","y":"public string  DirectoryIterator::key\n    ( void\n   )","p":null},"next":{"s":"Avanza al siguiente elemento DirectoryIterator","y":"public void  DirectoryIterator::next\n    ( void\n   )","p":null},"rewind":{"s":"Robobina DirectoryIterator hasta volver al inicio","y":"public void DirectoryIterator::rewind\n    ( void\n   )","p":null},"seek":{"s":"Mueve el apuntador interno del elemento DirectoryIterator","y":"public\n   void \n   DirectoryIterator::seek\n    ( int $position\n   )","p":[{"t":"position","d":"La base cero de la posici\u00f3n num\u00e9rica a mover el apuntador interno."}]},"__toString":{"s":"Obtiene el nombre del fichero como un string","y":"public\n   string \n   DirectoryIterator::__toString\n    ( void\n   )","p":null},"valid":{"s":"Comprueba si la actual posici\u00f3n de DirectoryIterator es un fichero v\u00e1lido","y":"public bool DirectoryIterator::valid\n    ( void\n   )","p":null}},"ArrayIterator":{"__construct":{"s":"Construye un ArrayIterator","y":"public ArrayIterator::__construct\n    ([ mixed $array = array()\n   [, int $flags = 0\n  ]] )","p":[{"t":"array","d":"El array o objecto a ser iterado."},{"t":"flags","d":"Banderas para controlar el comportamiento del objeto ArrayIterator.\n       V\u00e9ase ArrayIterator::setFlags()."}]},"append":{"s":"A\u00f1ade un elemento","y":"public void ArrayIterator::append\n    ( mixed $value\n   )","p":[{"t":"value","d":"El valor a a\u00f1adir."}]},"asort":{"s":"Ordena array por sus valores","y":"public void ArrayIterator::asort\n    ( void\n   )","p":null},"count":{"s":"Cuenta elementos","y":"public int ArrayIterator::count\n    ( void\n   )","p":null},"current":{"s":"Devuelve la entrada actual del array","y":"public mixed ArrayIterator::current\n    ( void\n   )","p":null},"getArrayCopy":{"s":"Obtener copia de un array","y":"public array ArrayIterator::getArrayCopy\n    ( void\n   )","p":null},"getFlags":{"s":"Obtener opciones","y":"public void ArrayIterator::getFlags\n    ( void\n   )","p":null},"key":{"s":"Devuelve la clave actual del array","y":"public mixed ArrayIterator::key\n    ( void\n   )","p":null},"ksort":{"s":"Ordena un array por sus claves","y":"public void ArrayIterator::ksort\n    ( void\n   )","p":null},"natcasesort":{"s":"Ordena un array de forma natural, sensible a may\u00fasculas","y":"public void ArrayIterator::natcasesort\n    ( void\n   )","p":null},"natsort":{"s":"Ordena un array de forma natural","y":"public void ArrayIterator::natsort\n    ( void\n   )","p":null},"next":{"s":"Desplaza a la siguiente entrada","y":"public void ArrayIterator::next\n    ( void\n   )","p":null},"offsetExists":{"s":"Compruebar si el \u00edndice existe","y":"public void ArrayIterator::offsetExists\n    ( string $index\n   )","p":[{"t":"index","d":"El \u00edndice a ser comprobado."}]},"offsetGet":{"s":"Obtener el valor de un \u00edndice","y":"public mixed ArrayIterator::offsetGet\n    ( string $index\n   )","p":[{"t":"index","d":"El \u00edndice para obtener el valor."}]},"offsetSet":{"s":"Establece el valor para un \u00edndice","y":"public void ArrayIterator::offsetSet\n    ( string $index\n   , string $newval\n   )","p":[{"t":"index","d":"El \u00edndice a ser establecido."},{"t":"newval","d":"El nuevo valor para almacenar en el \u00edndice."}]},"offsetUnset":{"s":"Destruye el valor de un \u00edndice","y":"public void ArrayIterator::offsetUnset\n    ( string $index\n   )","p":[{"t":"index","d":"El \u00edndice a ser destruido."}]},"rewind":{"s":"Rebobinar array al inicio","y":"public void ArrayIterator::rewind\n    ( void\n   )","p":null},"seek":{"s":"Buscar la posici\u00f3n","y":"public void ArrayIterator::seek\n    ( int $position\n   )","p":[{"t":"position","d":"La posici\u00f3n a buscar."}]},"serialize":{"s":"Serializar","y":"public string ArrayIterator::serialize\n    ( void\n   )","p":null},"setFlags":{"s":"Definir opciones de comportamiento","y":"public void ArrayIterator::setFlags\n    ( string $flags\n   )","p":[{"t":"flags","d":"Un bitmask como se indica:\n       \n        \n         0 = Propiedades del objeto tienen su normal comportamiento\n         cuando son obtenidas como lista (var_dump, foreach, etc.).\n        \n        \n         1 = \u00cdndicies de array pueden ser accedidos como propiedades de lectura\/escritura."}]},"uasort":{"s":"Ordenado definido por el usuario","y":"public void ArrayIterator::uasort\n    ( string $cmp_function\n   )","p":[{"t":"cmp_function","d":"La funci\u00f3n de comparaci\u00f3n usada para el ordenado."}]},"uksort":{"s":"Ordenado definido por el usuario","y":"public void ArrayIterator::uksort\n    ( string $cmp_function\n   )","p":[{"t":"cmp_function","d":"La funci\u00f3n de comparaci\u00f3n usada para el ordenado."}]},"unserialize":{"s":"Deserializar","y":"public string ArrayIterator::unserialize\n    ( string $serialized\n   )","p":[{"t":"serialized","d":"El objecto serializado ArrayIterator para deserializar."}]},"valid":{"s":"Comprueba si un array contiene m\u00e1s entradas","y":"public bool ArrayIterator::valid\n    ( void\n   )","p":null}},"RegexIterator":{"accept":{"s":"Obtener el estado de aceptaci\u00f3n","y":"public bool RegexIterator::accept\n    ( void\n   )","p":null},"__construct":{"s":"Crea un nuevo RegexIterator","y":"","p":[{"t":"iterator","d":"El iterador al que se le va a aplicar el filtro regex."},{"t":"regex","d":"la expresi\u00f3n regular a coincidir."},{"t":"mode","d":"Modo de operaci\u00f3n, v\u00e9ase RegexIterator::setMode() para una lista\n       de todos los modos."},{"t":"flags","d":"Flags especiales, v\u00e9ase RegexIterator::setFlags() para una lista\n       de todas las flags disponibles."},{"t":"preg_flags","d":"Las flags de expresi\u00f3n regular. Estas flags dependen de el par\u00e1metro de modo de operaci\u00f3n."}]},"getFlags":{"s":"Obtener flags","y":"public int RegexIterator::getFlags\n    ( void\n   )","p":null},"getMode":{"s":"Devuelve el modo de operaci\u00f3n","y":"public int RegexIterator::getMode\n    ( void\n   )","p":null},"getPregFlags":{"s":"Devuelve las flags de expresi\u00f3n regular","y":"public int RegexIterator::getPregFlags\n    ( void\n   )","p":null},"getRegex":{"s":"Devuelve la expresi\u00f3n regular actual","y":"public string RegexIterator::getRegex\n    ( void\n   )","p":null},"setFlags":{"s":"Establece las flags","y":"public void RegexIterator::setFlags\n    ( int $flags\n   )","p":[{"t":"flags","d":"Las flags a ser establecidas, \n       The flags to set, un bitmask de constantes de la clase."}]},"setMode":{"s":"Establece el modo de operaci\u00f3n","y":"public void RegexIterator::setMode\n    ( int $mode\n   )","p":[{"t":"mode","d":"El modo de operaci\u00f3n."}]},"setPregFlags":{"s":"Establece las flags de expresi\u00f3n regular","y":"public void RegexIterator::setPregFlags\n    ( int $preg_flags\n   )","p":[{"t":"preg_flags","d":"Las flags de expresi\u00f3n regular. V\u00e9ase RegexIterator::__construct()\n       para una lista de todas las flags disponibles."}]}},"Exception":{"__construct":{"s":"Constructor de la excepci\u00f3n","y":"","p":[{"t":"message","d":"Mensaje de la Excepci\u00f3n a lanzar."},{"t":"code","d":"El c\u00f3digo de la Excepci\u00f3n."},{"t":"previous","d":"La excepci\u00f3n previa usada por el encadenado de la excepci\u00f3n."}]},"getMessage":{"s":"Obtiene el mensaje de Excepci\u00f3n","y":"final public string Exception::getMessage\n    ( void\n   )","p":null},"getPrevious":{"s":"Devuelve la excepci\u00f3n anterior","y":"final public Exception Exception::getPrevious\n    ( void\n   )","p":null},"getCode":{"s":"Obtiene el c\u00f3digo de Excepci\u00f3n","y":"final public mixed Exception::getCode\n    ( void\n   )","p":null},"getFile":{"s":"Obtiene el fichero en el que ocurri\u00f3 la excepci\u00f3n","y":"final public string Exception::getFile\n    ( void\n   )","p":null},"getLine":{"s":"Obtiene la l\u00ednea en donde ocurri\u00f3 la excepci\u00f3n","y":"final public int Exception::getLine\n    ( void\n   )","p":null},"getTrace":{"s":"Obtiene el seguimiento de la pila","y":"final public array Exception::getTrace\n    ( void\n   )","p":null},"getTraceAsString":{"s":"Obtiene el stack trace como cadena","y":"final public string Exception::getTraceAsString\n    ( void\n   )","p":null},"__toString":{"s":"Representaci\u00f3n de la excepci\u00f3n en formato cadena","y":"public string  Exception::__toString\n    ( void\n   )","p":null},"__clone":{"s":"Clona la excepci\u00f3n","y":"final private void Exception::__clone\n    ( void\n   )","p":null}},"ErrorException":{"__construct":{"s":"Constructor de la Excepci\u00f3n","y":"","p":[{"t":"message","d":"Mensaje de la Excepci\u00f3n a lanzar."},{"t":"code","d":"El c\u00f3digo de la Excepci\u00f3n."},{"t":"severity","d":"Nivel de la severidad de la Excepci\u00f3n."},{"t":"filename","d":"Nombre del fichero donde se lanz\u00f3 la Excepci\u00f3n."},{"t":"lineno","d":"N\u00famero de la l\u00ednea donde se produjo la excepci\u00f3n."},{"t":"previous","d":"La anterior excepci\u00f3n utilizada para la excepci\u00f3n de encadenamiento."}]},"getSeverity":{"s":"Obtiene la severidad de la excepci\u00f3n","y":"final public int ErrorException::getSeverity\n    ( void\n   )","p":null}},"Closure":{"__construct":{"s":"Constructor que anula la instanciaci\u00f3n","y":"private Closure::__construct\n    ( void\n   )","p":null},"bind":{"s":"Duplicar una clausura con un objeto vinculado y \u00e1mbito de clase especificados","y":"public static Closure Closure::bind\n    ( Closure $closure\n   , object $newthis\n   [, mixed $newscope\n     = &quot;static&quot;\n  ] )","p":[{"t":"closure","d":"La funci\u00f3n an\u00f3nima a vincular."},{"t":"newthis","d":"El objeto al que la funci\u00f3n an\u00f3nima dada deber\u00eda ser vinculado, o\n      NULL para que la clausura sea desvinculada."},{"t":"newscope","d":"El \u00e1mbito de clase a la que asociar la clausura, o\n      &#039;static&#039; para mantener el actual. Si se proporciona un objeto, el tipo del\n      mismo se usar\u00e1 en su lugar. Esto determina la visibilidad de m\u00e9todos\n      protegidos y privados del objeto vinculado."}]},"bindTo":{"s":"Duplicar la clausura con un objeto vinculado y \u00e1mbito de clase nuevos","y":"public Closure Closure::bindTo\n    ( object $newthis\n   [, mixed $newscope\n     = &quot;static&quot;\n  ] )","p":[{"t":"newthis","d":"El objeto al que la funci\u00f3n an\u00f3nima dada deber\u00eda ser vinculado, o\n      NULL para que la clausura sea desvinculada."},{"t":"newscope","d":"El \u00e1mbito de clase a la que asociar la clausura, o\n      &#039;static&#039; para mantener el actual. Si se proporciona un objeto, el tipo del\n      mismo se usar\u00e1 en su lugar. Esto determina la visibilidad de m\u00e9todos\n      protegidos y privados del objeto vinculado."}]}},"DateTimeZone":{"__construct":{"s":"Crea un nuevo objeto DateTimeZone","y":"","p":[{"t":"timezone","d":"Una de las zonas horarias."}]},"getLocation":{"s":"Devuelve la informaci\u00f3n de la ubicaci\u00f3n para una zona horaria","y":"public array DateTimeZone::getLocation\n    ( void\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTimeZone\nes devuelto por timezone_open()"}]},"getName":{"s":"Devuelve el nombre de la zona horaria","y":"public string DateTimeZone::getName\n    ( void\n   )","p":[{"t":"object","d":"El DateTimeZone del cual desera obtener el nombre."}]},"getOffset":{"s":"Devuelve el \u00edndice de la zona horaria de GMT","y":"public int DateTimeZone::getOffset\n    ( DateTime $datetime\n   )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTimeZone\nes devuelto por timezone_open()"},{"t":"datetime","d":"El objeto DateTime que contiene la fecha\/hora desde la que se va a computar el \u00edndice."}]},"getTransitions":{"s":"Devuelve todas las transiciones para una zona horaria","y":"public array DateTimeZone::getTransitions\n    ([ int $timestamp_begin\n   [, int $timestamp_end\n  ]] )","p":[{"t":"object","d":"Estilo por procesos solamente: Un objeto DateTimeZone\nes devuelto por timezone_open()"},{"t":"timestamp_begin","d":"Marca de tiempo de inicio."},{"t":"timestamp_end","d":"Marca de tiempo final."}]},"listAbbreviations":{"s":"Devuelve una matriz asociativa que contiene el horario de verano (dst), el \u00edndice y el nombre de la zona horaria","y":"public static array DateTimeZone::listAbbreviations\n    ( void\n   )","p":null},"listIdentifiers":{"s":"Devuelve un array indexado num\u00e9ricamente que contiene todos los identificadores de zonas horarias definidos","y":"public static array DateTimeZone::listIdentifiers\n    ([ int $what = DateTimeZone::ALL\n   [, string $country = NULL\n  ]] )","p":[{"t":"what","d":"Una de las constantes de la clase DateTimeZone."},{"t":"country","d":"Un c\u00f3digo de pa\u00eds de dos letras compatible con ISO 3166-1."}]}},"DateInterval":{"__construct":{"s":"Crea un nuevo objeto DateInterval","y":"","p":[{"t":"interval_spec","d":"Una especificaci\u00f3n de intervalo."}]},"createFromDateString":{"s":"Establece un objeto DateInterval desde las partes relativas de una cadena","y":"public static DateInterval DateInterval::createFromDateString\n    ( string $time\n   )","p":[{"t":"time","d":"Una fecha con partes relativas. Espec\u00edficamente, los\n       formatos relativos\n       admitidos por el analizador utilzados para strtotime() y\n       DateTime se usar\u00e1n para construir el objeto\n       DateInterval."}]},"format":{"s":"Formatea el intervalo","y":"public string DateInterval::format\n    ( string $format\n   )","p":[{"t":"format","d":"Los siguietes caracteres est\u00e1n reconocidos en el\n         par\u00e1metro de cadena format.\n         Cada car\u00e1cter de formato debe ser prefijado con un signo\n         (%).\n        \n        \n         \n          \n           Car\u00e1cter format\n           Descripci\u00f3n\n           Valores de ejemplo\n          \n\n         \n\n         \n          \n           %\n           Literal %\n           %\n          \n\n          \n           Y\n           A\u00f1os, num\u00e9rico, al menos 2 d\u00edgitos empezando con 0\n           01, 03\n          \n\n          \n           y\n           A\u00f1os, num\u00e9rico\n           1, 3\n          \n\n          \n           M\n           Meses, num\u00e9rico, al menos 2 d\u00edgitos empezando con 0\n           01, 03, 12\n          \n\n          \n           m\n           Meses, num\u00e9rico\n           1, 3, 12\n          \n\n          \n           D\n           D\u00edas, num\u00e9rico, al menos 2 d\u00edgitos empezando con 0\n           01, 03, 31\n          \n\n          \n           d\n           D\u00edas, num\u00e9rico\n           1, 3, 31\n          \n\n          \n           a\n           N\u00famero total de d\u00edas como resultado de una operaci\u00f3n con DateTime::diff(), o de lo contrario (unknown)\n           4, 18, 8123\n          \n\n          \n           H\n           Horas, num\u00e9rico, al menos 2 d\u00edgitos empezando con 0\n           01, 03, 23\n          \n\n          \n           h\n           Horas, num\u00e9rico\n           1, 3, 23\n          \n\n          \n           I\n           Minutos, num\u00e9rico, al menos 2 d\u00edgitos empezando con 0\n           01, 03, 59\n          \n\n          \n           i\n           Minutos, num\u00e9rico\n           1, 3, 59\n          \n\n          \n           S\n           Segundos, num\u00e9rico, al menos 2 d\u00edgitos empezando con 0\n           01, 03, 57\n          \n\n          \n           s\n           Segundos, num\u00e9rico\n           1, 3, 57\n          \n\n          \n           R\n           Signo &quot;-&quot; cuando es negativo, &quot;+&quot; cuando es positivo\n           -, +\n          \n\n          \n           r\n           Signo &quot;-&quot; cuando es negativo, vac\u00edo cuando es positivo\n           -,"}]}},"DatePeriod":{"__construct":{"s":"Crea un nuevo objeto DatePeriod","y":"","p":[{"t":"start","d":"La fecha de inicio del periodo."},{"t":"interval","d":"El intervalo entre repeticiones dentro del periodo."},{"t":"recurrences","d":"El n\u00famero de repeticiones."},{"t":"end","d":"La fecha final del periodo."},{"t":"isostr","d":"Una especificaci\u00f3n ISO 8601 del intervalo de repetici\u00f3n."},{"t":"options","d":"Se puede establecer a DatePeriod::EXCLUDE_START_DATE para\n       excluir la fecha de inicio del conjunto de fechas de repetici\u00f3n dentro del\n       periodo."}]}},"LibXMLError":[],"DOMException":[],"LogicException":[],"IteratorIterator":{"__construct":{"s":"Crear un iterador de cualquier cosa que se pueda recorrer","y":"public IteratorIterator::__construct\n    ( Traversable $iterator\n   )","p":[{"t":"iterator","d":"El iterador recorrible."}]},"current":{"s":"Obtener el valor actual","y":"public mixed IteratorIterator::current\n    ( void\n   )","p":null},"getInnerIterator":{"s":"Obtener el iterador interno","y":"public Traversable IteratorIterator::getInnerIterator\n    ( void\n   )","p":null},"key":{"s":"Obtener la clave del elemento actual","y":"public scalar IteratorIterator::key\n    ( void\n   )","p":null},"next":{"s":"Avanzar al siguiente elemento","y":"public void IteratorIterator::next\n    ( void\n   )","p":null},"rewind":{"s":"Rebobinar al primer elemento","y":"public void IteratorIterator::rewind\n    ( void\n   )","p":null},"valid":{"s":"Comprobar si el iterador es v\u00e1lido","y":"public bool IteratorIterator::valid\n    ( void\n   )","p":null}},"FilterIterator":{"accept":{"s":"Comprueba si el elemento actual del iterador es aceptable","y":"public\n   abstract\n   bool FilterIterator::accept\n    ( void\n   )","p":null},"__construct":{"s":"Construye un filterIterator","y":"public\n   FilterIterator::__construct\n    ( Iterator $iterator\n   )","p":[{"t":"iterator","d":"El iterador que va a ser filtrado."}]},"current":{"s":"Obtiene el valor del elemento actual","y":"public mixed FilterIterator::current\n    ( void\n   )","p":null},"getInnerIterator":{"s":"Obtiene el iterador interno","y":"public Iterator FilterIterator::getInnerIterator\n    ( void\n   )","p":null},"key":{"s":"Obtiene la clave actual","y":"public mixed FilterIterator::key\n    ( void\n   )","p":null},"next":{"s":"Mueve el iterador a la siguiente posici\u00f3n","y":"public void FilterIterator::next\n    ( void\n   )","p":null},"rewind":{"s":"Rebobina el iterador","y":"public void FilterIterator::rewind\n    ( void\n   )","p":null},"valid":{"s":"Comprueba si el elemento actual es v\u00e1lido","y":"public bool FilterIterator::valid\n    ( void\n   )","p":null}},"XMLReader":{"close":{"s":"Cierra la entrada del XMLReader","y":"public bool XMLReader::close\n    ( void\n   )","p":null},"expand":{"s":"Devuelve una copia del actual nodo como un objeto DOM","y":"public\n   DOMNode \n   XMLReader::expand\n    ([ DOMNode $basenode\n  ] )","p":null},"getAttribute":{"s":"Obtiener el valor del atributo nombrado","y":"public\n   string \n   XMLReader::getAttribute\n    ( string $name\n   )","p":[{"t":"name","d":"El nombre del atributo."}]},"getAttributeNo":{"s":"Obtiene el valor de un atributo por el indice","y":"public\n   string \n   XMLReader::getAttributeNo\n    ( int $index\n   )","p":[{"t":"index","d":"La posici\u00f3n del atributo."}]},"getAttributeNs":{"s":"Obtiene el valor de un atributo por su nombre local y URI","y":"public string XMLReader::getAttributeNs\n    ( string $localName\n   , string $namespaceURI\n   )","p":[{"t":"localName","d":"El nombre local."},{"t":"namespaceURI","d":"El URI del namespace."}]},"getParserProperty":{"s":"Indica si la porpiedad especificada ha sido establecida ","y":"public bool XMLReader::getParserProperty\n    ( int $property\n   )","p":[{"t":"property","d":"Una de las constantes analizadoras de \n       opci\u00f3n."}]},"isValid":{"s":"Indica si el documento analizado es v\u00e1lido","y":"public bool XMLReader::isValid\n    ( void\n   )","p":null},"lookupNamespace":{"s":"Busca el namespace para un prefijo","y":"public\n   bool \n   XMLReader::lookupNamespace\n    ( string $prefix\n   )","p":[{"t":"prefix","d":"La cadena conteniendo el prefijo."}]},"moveToAttribute":{"s":"Mueve el cursor a un atributo nombrado","y":"public\n   bool \n   XMLReader::moveToAttribute\n    ( string $name\n   )","p":[{"t":"name","d":"El nombre del atributo."}]},"moveToAttributeNo":{"s":"Mueve el cursor a un atributo por su \u00edndice","y":"public\n   bool \n   XMLReader::moveToAttributeNo\n    ( int $index\n   )","p":[{"t":"index","d":"La posici\u00f3n de el atributo."}]},"moveToAttributeNs":{"s":"Mover el cursor a un atributo dado","y":"public\n   bool \n   XMLReader::moveToAttributeNs\n    ( string $localName\n   , string $namespaceURI\n   )","p":[{"t":"localName","d":"El nombre local."},{"t":"namespaceURI","d":"El URI namespace."}]},"moveToElement":{"s":"Posiciona el cursor en el elem\u00e9nto padre del actual atributo","y":"public bool XMLReader::moveToElement\n    ( void\n   )","p":null},"moveToFirstAttribute":{"s":"Posiciona el cursor en el primer atributo","y":"public bool XMLReader::moveToFirstAttribute\n    ( void\n   )","p":null},"moveToNextAttribute":{"s":"Posiciona el cursor en el siguiente atributo","y":"public bool XMLReader::moveToNextAttribute\n    ( void\n   )","p":null},"next":{"s":"Mueve el cursor al siguiente nodo saltandose todos los sub\u00e1rboles","y":"public\n   bool \n   XMLReader::next\n    ([ string $localname\n  ] )","p":[{"t":"localname","d":"El nodo del siguiente nodoa mover el cursor."}]},"open":{"s":"Establece el URI conteniendo el XML a analizar","y":"public\n   bool \n   XMLReader::open\n    ( string $URI\n   [, string $encoding\n   [, int $options = 0\n  ]] )","p":[{"t":"URI","d":"El URI se\u00f1alado para el documento."},{"t":"encoding","d":"El documento codificado o NULL."},{"t":"options","d":"Una mascara de bit de las contantes de LIBXML_*."}]},"read":{"s":"Se mueve al siguiente nodo en el documento","y":"public bool XMLReader::read\n    ( void\n   )","p":null},"readInnerXML":{"s":"Recupera el XML del actual nodo","y":"public string XMLReader::readInnerXML\n    ( void\n   )","p":null},"readOuterXML":{"s":"Recupera el XML del actual nodo, incluyendo \u00e9l mismo","y":"public string XMLReader::readOuterXML\n    ( void\n   )","p":null},"readString":{"s":"Lee el contenido del nodo actual como string","y":"public string XMLReader::readString\n    ( void\n   )","p":null},"setParserProperty":{"s":"Establecer las opciones del analizador","y":"public\n   bool \n   XMLReader::setParserProperty\n    ( int $property\n   , bool $value\n   )","p":[{"t":"property","d":"Una de las constantes de opci\u00f3n\n       del analizador."},{"t":"value","d":"Si se establece a TRUE la opci\u00f3n ser\u00e1 habilitada, de otra manera\n       ser\u00e1 deshabilitada."}]},"setRelaxNGSchema":{"s":"Establece el nomb re del archivo o el URI para un esquema RelaxNG","y":"public\n   bool \n   XMLReader::setRelaxNGSchema\n    ( string $filename\n   )","p":[{"t":"filename","d":"El nombre del archivo o apuntador URI a un esquema RelaxNG."}]},"setRelaxNGSchemaSource":{"s":"Establece los datos contenidos en un esquema RelaxNG","y":"public\n   bool \n   XMLReader::setRelaxNGSchemaSource\n    ( string $source\n   )","p":[{"t":"source","d":"SCadena que contiene el esquema RelaxNG."}]},"setSchema":{"s":"Valida el documento en contra del XSD","y":"public bool XMLReader::setSchema\n    ( string $filename\n   )","p":[{"t":"filename","d":"El nombre del archivo del esquema XSD."}]},"XML":{"s":"Establece el contenido del XML a analizar","y":"public\n   bool \n   XMLReader::xml\n    ( string $source\n   [, string $encoding\n   [, int $options = 0\n  ]] )","p":[{"t":"source","d":"La cadena que contiene el XML a ser analizado."},{"t":"encoding","d":"La codificaci\u00f3n del documento o NULL."},{"t":"options","d":"Una mascara bit de la constante LIBXML_*."}]}},"XMLWriter":[],"ZipArchive":{"addEmptyDir":{"s":"A\u00f1adir un nuevo directorio","y":"bool ZipArchive::addEmptyDir\n    ( string $dirname\n   )","p":[{"t":"dirname","d":"El directorio a a\u00f1adir."}]},"addFile":{"s":"A\u00f1ade un fichero al archivo ZIP para la ruta dada","y":"bool ZipArchive::addFile\n    ( string $filename\n   [, string $localname = NULL\n   [, int $start = 0\n   [, int $length = 0\n  ]]] )","p":[{"t":"filename","d":"La ruta del fichero a a\u00f1adir."},{"t":"localname","d":"Si corresponde, este es el nombre local dentro del archivo ZIP que reemplazar\u00e1 el filename."},{"t":"start","d":"Este par\u00e1metro no se utiliza, pero es requerido si se extiende ZipArchive."},{"t":"length","d":"Este par\u00e1metro no se utiliza, pero es requerido si se extiende ZipArchive."}]},"addFromString":{"s":"A\u00f1adir un fichero al archivo ZIP usando su contenido","y":"bool ZipArchive::addFromString\n    ( string $localname\n   , string $contents\n   )","p":[{"t":"localname","d":"Nombre de la entrada a crear."},{"t":"contents","d":"El contenido a usar para crear la entrada. Es usado en modo\n       binary safe."}]},"addGlob":{"s":"A\u00f1adir ficheros de un directorio mediante un patr\u00f3n glob","y":"bool ZipArchive::addGlob\n    ( string $pattern\n   [, int $flags = 0\n   [, array $options = array()\n  ]] )","p":[{"t":"pattern","d":"Un patr\u00f3n glob()contra el cual se har\u00e1 la correspondencia con los ficheros."},{"t":"flags","d":"Una m\u00e1scara de un bit de marcas glob()."},{"t":"options","d":"Un array asociativo de opciones. Las opciones disponibles son:\n      \n       \n        \n         &quot;add_path&quot;"}]},"addPattern":{"s":"A\u00f1ade ficheros de un directorio a partir de un patr\u00f3n PCRE ","y":"bool ZipArchive::addPattern\n    ( string $pattern\n   [, string $path = &#039;.&#039;\n   [, array $options = array()\n  ]] )","p":[{"t":"pattern","d":"Un patr\u00f3n PCRE contra el cual se realizar\u00e1 la correspondencia."},{"t":"path","d":"El directorio que ser\u00e1 escaneado. Por defecto es el directorio de trabajo actual."},{"t":"options","d":"Un array asociativo de opciones aceptadas por ZipArchive::addGlob()."}]},"close":{"s":"Cierra el fichero activo (abierto o el nuevo creado)","y":"bool ZipArchive::close\n    ( void\n   )","p":null},"deleteIndex":{"s":"Elimina una entrada en el archivo usando su \u00edndice","y":"bool ZipArchive::deleteIndex\n    ( int $index\n   )","p":[{"t":"index","d":"\u00cdndice de la entrada a eliminar."}]},"deleteName":{"s":"Elimina una entrada en el archivo por su nombre","y":"bool ZipArchive::deleteName\n    ( string $name\n   )","p":[{"t":"name","d":"Nombre de la entrada a eliminar."}]},"extractTo":{"s":"Extraer el contenido del archivo","y":"bool ZipArchive::extractTo\n    ( string $destination\n   [, mixed $entries\n  ] )","p":[{"t":"destination","d":"Destino en donde extraer los ficheros."},{"t":"entries","d":"Las entradas a extraer. Acepta tanto un solo nombre o un array\n       de nombres."}]},"getArchiveComment":{"s":"Devuelve el comentario del archivo ZIP","y":"string ZipArchive::getArchiveComment\n    ([ int $flags\n  ] )","p":[{"t":"flags","d":"Si las flags se establecen en ZipArchive::FL_UNCHANGED, el\n       comentario original se devuelve sin cambios."}]},"getCommentIndex":{"s":"Devuelve el comentario de una entrada usando la entrada d\u00edndice","y":"string ZipArchive::getCommentIndex\n    ( int $index\n   [, int $flags\n  ] )","p":[{"t":"index","d":"\u00cdndice de la entrada"},{"t":"flags","d":"Si flags ZipArchive::FL_UNCHANGED, se devolver\u00e1 \n       el comentario original no cambiado."}]},"getCommentName":{"s":"Devuelve el comentario de una entrada usando el nombre de la entrada","y":"string ZipArchive::getCommentName\n    ( string $name\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Nombre de la entrada"},{"t":"flags","d":"Si flags est\u00e1 defindo a ZipArchive::FL_UNCHANGED, se devuelve el\n       comentario original no cambiado."}]},"getExternalAttributesIndex":{"s":"Retrieve the external attributes of an entry defined by its index","y":"bool \n   ZipArchive::GetExternalAttributesIndex\n    ( int $index\n   , int &$opsys\n   , int &$attr\n   [, int $flags\n  ] )","p":[{"t":"index","d":"Index of the entry."},{"t":"opsys","d":"On success, receive the operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"On success, receive the external attributes. Value depends on operating system."},{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       attributes are returned."}]},"getExternalAttributesName":{"s":"Retrieve the external attributes of an entry defined by its name","y":"bool \n   ZipArchive::getExternalAttributesName\n    ( string $name\n   , int &$opsys\n   , int &$attr\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Name of the entry."},{"t":"opsys","d":"On success, receive the operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"On success, receive the external attributes. Value depends on operating system."},{"t":"flags","d":"If flags is set to ZipArchive::FL_UNCHANGED, the original unchanged\n       attributes are returned."}]},"getFromIndex":{"s":"Devuelve el contenido de la entrada usando su \u00edndice","y":"string ZipArchive::getFromIndex\n    ( int $index\n   [, int $length = 0   \n   [, int $flags\n  ]] )","p":[{"t":"index","d":"El \u00edndice de la entrada"},{"t":"length","d":"La longitud  que se see desde la entrada. Si es 0, entonces\n       toda la entrada se lee."},{"t":"flags","d":"Las flags usadas para abrir el fichero. Los siguientes valores\n       pueden ser Ored.\n       \n        \n         \n          ZipArchive::FL_UNCHANGED"}]},"getFromName":{"s":"Devuelve el contenido de la entrada utilizando su nombre","y":"mixed ZipArchive::getFromName\n    ( string $name\n   [, int $length = 0   \n   [, int $flags\n  ]] )","p":[{"t":"name","d":"Nombre de la entrada"},{"t":"length","d":"La longitud  que se see desde la entrada. Si es 0, entonces\n       toda la entrada se lee."},{"t":"flags","d":"Los indicadores a utilizar para abrir el archivo. Los siguientes valores podr\u00edan\n       ser escritos juntos con un OR l\u00f3gico en \u00e9l.\n       \n        \n         \n          ZIPARCHIVE::FL_UNCHANGED"}]},"getNameIndex":{"s":"Devuelve el nombre de una entrada utilizando su \u00edndice","y":"string ZipArchive::getNameIndex\n    ( int $index\n   [, int $flags\n  ] )","p":[{"t":"index","d":"El \u00edndice de la entrada."},{"t":"flags","d":"Si las flags se establecen en ZipArchive::FL_UNCHANGED, el nombre original es\n       devuelto sin cambios."}]},"getStatusString":{"s":"Devuelve mensajes de: estado de error, de sistema y\/o mensajes de zip","y":"string ZipArchive::getStatusString\n    ( void\n   )","p":null},"getStream":{"s":"Obtener un manejador de fichero para la entrada definido por su nombre (s\u00f3lo lectura)","y":"resource ZipArchive::getStream\n    ( string $name\n   )","p":[{"t":"name","d":"El nombre de la entrada a utilizar."}]},"locateName":{"s":"Devuelve el \u00edndice de la entrada en el archivo","y":"mixed ZipArchive::locateName\n    ( string $name\n   [, int $flags\n  ] )","p":[{"t":"name","d":"El nombre de la entrada a buscar"},{"t":"flags","d":"Los indicadores son especificados agreg\u00e1ndoles OR a los siguientes valores, \u00f3 0 para ninguno de ellos.\n       \n        \n         \n          ZIPARCHIVE::FL_NOCASE"}]},"open":{"s":"Abrir un fichero de archivo en formato ZIP","y":"mixed ZipArchive::open\n    ( string $filename\n   [, int $flags\n  ] )","p":[{"t":"filename","d":"El nombre del fichero del archivo ZIP para ser abierto."},{"t":"flags","d":"El modo a utilizar para abrir el archivo.\n       \n        \n         \n          ZIPARCHIVE::OVERWRITE"}]},"renameIndex":{"s":"Renombra una entrada definida por su \u00edndice","y":"bool ZipArchive::renameIndex\n    ( int $index\n   , string $newname\n   )","p":[{"t":"index","d":"\u00cdndice de la entrada a renombrar."},{"t":"newname","d":"Nombre nuevo."}]},"renameName":{"s":"Renombra una entrada definida por su nombre","y":"bool ZipArchive::renameName\n    ( string $name\n   , string $newname\n   )","p":[{"t":"name","d":"Nombre de la entrada a renombrar."},{"t":"newname","d":"Nombre nuevo."}]},"setArchiveComment":{"s":"Establece el comentario de un archivo ZIP","y":"mixed ZipArchive::setArchiveComment\n    ( string $comment\n   )","p":[{"t":"comment","d":"Los contenidos del comentario."}]},"setCommentIndex":{"s":"Establece el comentario de una entrada definido por su \u00edndice","y":"mixed ZipArchive::setCommentIndex\n    ( int $index\n   , string $comment\n   )","p":[{"t":"index","d":"\u00cdndice de la entrada."},{"t":"comment","d":"Los contenidos del comentario."}]},"setCommentName":{"s":"Establece el comentario de una entrada definido por su nombre","y":"mixed ZipArchive::setCommentName\n    ( string $name\n   , string $comment\n   )","p":[{"t":"name","d":"Nombre de la entrada."},{"t":"comment","d":"Los contenidos del comentario."}]},"setExternalAttributesIndex":{"s":"Set the external attributes of an entry defined by its index","y":"bool \n   ZipArchive::setExternalAttributesIndex\n    ( int $index\n   , int $opsys\n   , int $attr\n   [, int $flags\n  ] )","p":[{"t":"index","d":"Index of the entry."},{"t":"opsys","d":"The operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"The external attributes. Value depends on operating system."},{"t":"flags","d":"Optional flags. Currently unused."}]},"setExternalAttributesName":{"s":"Set the external attributes of an entry defined by its name","y":"bool \n   ZipArchive::setExternalAttributesName\n    ( string $name\n   , int $opsys\n   , int $attr\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Name of the entry."},{"t":"opsys","d":"The operating system code defined by one of the ZipArchive::OPSYS_ constants."},{"t":"attr","d":"The external attributes. Value depends on operating system."},{"t":"flags","d":"Optional flags. Currently unused."}]},"statIndex":{"s":"Obtiene los detalles de una entrada definida por su \u00edndice","y":"mixed ZipArchive::statIndex\n    ( int $index\n   [, int $flags\n  ] )","p":[{"t":"index","d":"\u00cdndice de la entrada"},{"t":"flags","d":"ZIPARCHIVE::FL_UNCHANGED podr\u00eda ser puesto con otros OR l\u00f3gicos en \u00e9l para pedir\n       informaci\u00f3n  acerca del fichero original en el archivo,\n       ignorando cualquiera de los cambios hechos."}]},"statName":{"s":"Obtener los detalles de una entrada definida por su nombre","y":"mixed ZipArchive::statName\n    ( string $name\n   [, int $flags\n  ] )","p":[{"t":"name","d":"Nombre de la entrada"},{"t":"flags","d":"El argumento flags especifica c\u00f3mo la b\u00fasqueda del nombre deber\u00eda se hecho.\n       Tambi\u00e9n, ZIPARCHIVE::FL_UNCHANGED podr\u00eda ser puesta con otros OR en \u00e9l para solicitar la\n       informaci\u00f3n acerca del fichero original en el archivo,\n       ignorando cualquier cambio realizado.\n       \n        \n         \n          ZIPARCHIVE::FL_NOCASE"}]},"unchangeAll":{"s":"Deshacer todos los cambios hechos en el archivo","y":"mixed ZipArchive::unchangeAll\n    ( void\n   )","p":null},"unchangeArchive":{"s":"Revertir todos los cambios globales hechos en el archivo","y":"mixed ZipArchive::unchangeArchive\n    ( void\n   )","p":null},"unchangeIndex":{"s":"Revertir todos los cambios hechos a una entrada en el \u00edndice dado","y":"mixed ZipArchive::unchangeIndex\n    ( int $index\n   )","p":[{"t":"index","d":"\u00cdndice de la entrada."}]},"unchangeName":{"s":"Deshace todos los cambios realizados a una entrada con un nombre dado","y":"bool ZipArchive::unchangeName\n    ( string $name\n   )","p":[{"t":"name","d":"Nombre de la entrada."}]}}}